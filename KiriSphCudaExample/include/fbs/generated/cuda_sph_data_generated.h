// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "basic_types_generated.h"

namespace KIRI {
namespace FlatBuffers {

struct SphInitBoxVolume;
struct SphInitBoxVolumeBuilder;

struct CudaSphData;
struct CudaSphDataBuilder;

struct SphInitBoxVolume FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphInitBoxVolumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOX_LOWER = 4,
    VT_BOX_SIZE = 6,
    VT_BOX_COLOR = 8
  };
  const KIRI::FlatBuffers::float3 *box_lower() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_LOWER);
  }
  const KIRI::FlatBuffers::int3 *box_size() const {
    return GetStruct<const KIRI::FlatBuffers::int3 *>(VT_BOX_SIZE);
  }
  const KIRI::FlatBuffers::float3 *box_color() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_LOWER) &&
           VerifyField<KIRI::FlatBuffers::int3>(verifier, VT_BOX_SIZE) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_COLOR) &&
           verifier.EndTable();
  }
};

struct SphInitBoxVolumeBuilder {
  typedef SphInitBoxVolume Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_box_lower(const KIRI::FlatBuffers::float3 *box_lower) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_LOWER, box_lower);
  }
  void add_box_size(const KIRI::FlatBuffers::int3 *box_size) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_SIZE, box_size);
  }
  void add_box_color(const KIRI::FlatBuffers::float3 *box_color) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_COLOR, box_color);
  }
  explicit SphInitBoxVolumeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphInitBoxVolume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphInitBoxVolume>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphInitBoxVolume> CreateSphInitBoxVolume(
    flatbuffers::FlatBufferBuilder &_fbb,
    const KIRI::FlatBuffers::float3 *box_lower = 0,
    const KIRI::FlatBuffers::int3 *box_size = 0,
    const KIRI::FlatBuffers::float3 *box_color = 0) {
  SphInitBoxVolumeBuilder builder_(_fbb);
  builder_.add_box_color(box_color);
  builder_.add_box_size(box_size);
  builder_.add_box_lower(box_lower);
  return builder_.Finish();
}

struct CudaSphData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaSphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REST_DENSITY = 4,
    VT_REST_MASS = 6,
    VT_KERNEL_RADIUS = 8,
    VT_PARTICLE_RADIUS = 10,
    VT_STIFF = 12,
    VT_GRAVITY = 14,
    VT_ENABLE_ATF_VISC = 16,
    VT_VISC = 18,
    VT_NU = 20,
    VT_BNU = 22,
    VT_FIXED_DT = 24
  };
  float rest_density() const {
    return GetField<float>(VT_REST_DENSITY, 0.0f);
  }
  float rest_mass() const {
    return GetField<float>(VT_REST_MASS, 0.0f);
  }
  float kernel_radius() const {
    return GetField<float>(VT_KERNEL_RADIUS, 0.0f);
  }
  float particle_radius() const {
    return GetField<float>(VT_PARTICLE_RADIUS, 0.0f);
  }
  float stiff() const {
    return GetField<float>(VT_STIFF, 0.0f);
  }
  const KIRI::FlatBuffers::float3 *gravity() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_GRAVITY);
  }
  bool enable_atf_visc() const {
    return GetField<uint8_t>(VT_ENABLE_ATF_VISC, 0) != 0;
  }
  float visc() const {
    return GetField<float>(VT_VISC, 0.0f);
  }
  float nu() const {
    return GetField<float>(VT_NU, 0.0f);
  }
  float bnu() const {
    return GetField<float>(VT_BNU, 0.0f);
  }
  float fixed_dt() const {
    return GetField<float>(VT_FIXED_DT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_REST_DENSITY) &&
           VerifyField<float>(verifier, VT_REST_MASS) &&
           VerifyField<float>(verifier, VT_KERNEL_RADIUS) &&
           VerifyField<float>(verifier, VT_PARTICLE_RADIUS) &&
           VerifyField<float>(verifier, VT_STIFF) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_GRAVITY) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ATF_VISC) &&
           VerifyField<float>(verifier, VT_VISC) &&
           VerifyField<float>(verifier, VT_NU) &&
           VerifyField<float>(verifier, VT_BNU) &&
           VerifyField<float>(verifier, VT_FIXED_DT) &&
           verifier.EndTable();
  }
};

struct CudaSphDataBuilder {
  typedef CudaSphData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rest_density(float rest_density) {
    fbb_.AddElement<float>(CudaSphData::VT_REST_DENSITY, rest_density, 0.0f);
  }
  void add_rest_mass(float rest_mass) {
    fbb_.AddElement<float>(CudaSphData::VT_REST_MASS, rest_mass, 0.0f);
  }
  void add_kernel_radius(float kernel_radius) {
    fbb_.AddElement<float>(CudaSphData::VT_KERNEL_RADIUS, kernel_radius, 0.0f);
  }
  void add_particle_radius(float particle_radius) {
    fbb_.AddElement<float>(CudaSphData::VT_PARTICLE_RADIUS, particle_radius, 0.0f);
  }
  void add_stiff(float stiff) {
    fbb_.AddElement<float>(CudaSphData::VT_STIFF, stiff, 0.0f);
  }
  void add_gravity(const KIRI::FlatBuffers::float3 *gravity) {
    fbb_.AddStruct(CudaSphData::VT_GRAVITY, gravity);
  }
  void add_enable_atf_visc(bool enable_atf_visc) {
    fbb_.AddElement<uint8_t>(CudaSphData::VT_ENABLE_ATF_VISC, static_cast<uint8_t>(enable_atf_visc), 0);
  }
  void add_visc(float visc) {
    fbb_.AddElement<float>(CudaSphData::VT_VISC, visc, 0.0f);
  }
  void add_nu(float nu) {
    fbb_.AddElement<float>(CudaSphData::VT_NU, nu, 0.0f);
  }
  void add_bnu(float bnu) {
    fbb_.AddElement<float>(CudaSphData::VT_BNU, bnu, 0.0f);
  }
  void add_fixed_dt(float fixed_dt) {
    fbb_.AddElement<float>(CudaSphData::VT_FIXED_DT, fixed_dt, 0.0f);
  }
  explicit CudaSphDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaSphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaSphData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaSphData> CreateCudaSphData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rest_density = 0.0f,
    float rest_mass = 0.0f,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool enable_atf_visc = false,
    float visc = 0.0f,
    float nu = 0.0f,
    float bnu = 0.0f,
    float fixed_dt = 0.0f) {
  CudaSphDataBuilder builder_(_fbb);
  builder_.add_fixed_dt(fixed_dt);
  builder_.add_bnu(bnu);
  builder_.add_nu(nu);
  builder_.add_visc(visc);
  builder_.add_gravity(gravity);
  builder_.add_stiff(stiff);
  builder_.add_particle_radius(particle_radius);
  builder_.add_kernel_radius(kernel_radius);
  builder_.add_rest_mass(rest_mass);
  builder_.add_rest_density(rest_density);
  builder_.add_enable_atf_visc(enable_atf_visc);
  return builder_.Finish();
}

}  // namespace FlatBuffers
}  // namespace KIRI

#endif  // FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_
