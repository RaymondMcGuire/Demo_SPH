// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CUDAMULTISPHDATA_KIRI_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CUDAMULTISPHDATA_KIRI_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "basic_types_generated.h"
#include "cuda_sph_data_generated.h"

namespace KIRI {
namespace FlatBuffers {

struct MultiSphInitBoxVolume;
struct MultiSphInitBoxVolumeBuilder;

struct CudaMultiSphData;
struct CudaMultiSphDataBuilder;

struct CudaMultiSphYan16Data;
struct CudaMultiSphYan16DataBuilder;

struct MultiSphInitBoxVolume FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiSphInitBoxVolumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOX_LOWER = 4,
    VT_BOX_SIZE = 6
  };
  const KIRI::FlatBuffers::float3 *box_lower() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_LOWER);
  }
  const KIRI::FlatBuffers::int3 *box_size() const {
    return GetStruct<const KIRI::FlatBuffers::int3 *>(VT_BOX_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_LOWER) &&
           VerifyField<KIRI::FlatBuffers::int3>(verifier, VT_BOX_SIZE) &&
           verifier.EndTable();
  }
};

struct MultiSphInitBoxVolumeBuilder {
  typedef MultiSphInitBoxVolume Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_box_lower(const KIRI::FlatBuffers::float3 *box_lower) {
    fbb_.AddStruct(MultiSphInitBoxVolume::VT_BOX_LOWER, box_lower);
  }
  void add_box_size(const KIRI::FlatBuffers::int3 *box_size) {
    fbb_.AddStruct(MultiSphInitBoxVolume::VT_BOX_SIZE, box_size);
  }
  explicit MultiSphInitBoxVolumeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MultiSphInitBoxVolume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiSphInitBoxVolume>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiSphInitBoxVolume> CreateMultiSphInitBoxVolume(
    flatbuffers::FlatBufferBuilder &_fbb,
    const KIRI::FlatBuffers::float3 *box_lower = 0,
    const KIRI::FlatBuffers::int3 *box_size = 0) {
  MultiSphInitBoxVolumeBuilder builder_(_fbb);
  builder_.add_box_size(box_size);
  builder_.add_box_lower(box_lower);
  return builder_.Finish();
}

struct CudaMultiSphData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaMultiSphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHASE_NUM = 4,
    VT_RHO0 = 6,
    VT_MASS0 = 8,
    VT_COLOR0 = 10,
    VT_VISC0 = 12,
    VT_KERNEL_RADIUS = 14,
    VT_PARTICLE_RADIUS = 16,
    VT_STIFF = 18,
    VT_SOUND_SPEED = 20,
    VT_BNU = 22,
    VT_GRAVITY = 24,
    VT_MISCIBLE = 26,
    VT_TOU = 28,
    VT_SIGMA = 30,
    VT_FIXED_DT = 32
  };
  int32_t phase_num() const {
    return GetField<int32_t>(VT_PHASE_NUM, 0);
  }
  const flatbuffers::Vector<float> *rho0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RHO0);
  }
  const flatbuffers::Vector<float> *mass0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MASS0);
  }
  const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *color0() const {
    return GetPointer<const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *>(VT_COLOR0);
  }
  const flatbuffers::Vector<float> *visc0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VISC0);
  }
  float kernel_radius() const {
    return GetField<float>(VT_KERNEL_RADIUS, 0.0f);
  }
  float particle_radius() const {
    return GetField<float>(VT_PARTICLE_RADIUS, 0.0f);
  }
  float stiff() const {
    return GetField<float>(VT_STIFF, 0.0f);
  }
  float sound_speed() const {
    return GetField<float>(VT_SOUND_SPEED, 0.0f);
  }
  float bnu() const {
    return GetField<float>(VT_BNU, 0.0f);
  }
  const KIRI::FlatBuffers::float3 *gravity() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_GRAVITY);
  }
  bool miscible() const {
    return GetField<uint8_t>(VT_MISCIBLE, 0) != 0;
  }
  float tou() const {
    return GetField<float>(VT_TOU, 0.0f);
  }
  float sigma() const {
    return GetField<float>(VT_SIGMA, 0.0f);
  }
  float fixed_dt() const {
    return GetField<float>(VT_FIXED_DT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PHASE_NUM) &&
           VerifyOffset(verifier, VT_RHO0) &&
           verifier.VerifyVector(rho0()) &&
           VerifyOffset(verifier, VT_MASS0) &&
           verifier.VerifyVector(mass0()) &&
           VerifyOffset(verifier, VT_COLOR0) &&
           verifier.VerifyVector(color0()) &&
           VerifyOffset(verifier, VT_VISC0) &&
           verifier.VerifyVector(visc0()) &&
           VerifyField<float>(verifier, VT_KERNEL_RADIUS) &&
           VerifyField<float>(verifier, VT_PARTICLE_RADIUS) &&
           VerifyField<float>(verifier, VT_STIFF) &&
           VerifyField<float>(verifier, VT_SOUND_SPEED) &&
           VerifyField<float>(verifier, VT_BNU) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_GRAVITY) &&
           VerifyField<uint8_t>(verifier, VT_MISCIBLE) &&
           VerifyField<float>(verifier, VT_TOU) &&
           VerifyField<float>(verifier, VT_SIGMA) &&
           VerifyField<float>(verifier, VT_FIXED_DT) &&
           verifier.EndTable();
  }
};

struct CudaMultiSphDataBuilder {
  typedef CudaMultiSphData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_phase_num(int32_t phase_num) {
    fbb_.AddElement<int32_t>(CudaMultiSphData::VT_PHASE_NUM, phase_num, 0);
  }
  void add_rho0(flatbuffers::Offset<flatbuffers::Vector<float>> rho0) {
    fbb_.AddOffset(CudaMultiSphData::VT_RHO0, rho0);
  }
  void add_mass0(flatbuffers::Offset<flatbuffers::Vector<float>> mass0) {
    fbb_.AddOffset(CudaMultiSphData::VT_MASS0, mass0);
  }
  void add_color0(flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> color0) {
    fbb_.AddOffset(CudaMultiSphData::VT_COLOR0, color0);
  }
  void add_visc0(flatbuffers::Offset<flatbuffers::Vector<float>> visc0) {
    fbb_.AddOffset(CudaMultiSphData::VT_VISC0, visc0);
  }
  void add_kernel_radius(float kernel_radius) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_KERNEL_RADIUS, kernel_radius, 0.0f);
  }
  void add_particle_radius(float particle_radius) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_PARTICLE_RADIUS, particle_radius, 0.0f);
  }
  void add_stiff(float stiff) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_STIFF, stiff, 0.0f);
  }
  void add_sound_speed(float sound_speed) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_SOUND_SPEED, sound_speed, 0.0f);
  }
  void add_bnu(float bnu) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_BNU, bnu, 0.0f);
  }
  void add_gravity(const KIRI::FlatBuffers::float3 *gravity) {
    fbb_.AddStruct(CudaMultiSphData::VT_GRAVITY, gravity);
  }
  void add_miscible(bool miscible) {
    fbb_.AddElement<uint8_t>(CudaMultiSphData::VT_MISCIBLE, static_cast<uint8_t>(miscible), 0);
  }
  void add_tou(float tou) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_TOU, tou, 0.0f);
  }
  void add_sigma(float sigma) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_SIGMA, sigma, 0.0f);
  }
  void add_fixed_dt(float fixed_dt) {
    fbb_.AddElement<float>(CudaMultiSphData::VT_FIXED_DT, fixed_dt, 0.0f);
  }
  explicit CudaMultiSphDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaMultiSphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaMultiSphData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaMultiSphData> CreateCudaMultiSphData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t phase_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> rho0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> mass0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> color0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> visc0 = 0,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    float sound_speed = 0.0f,
    float bnu = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool miscible = false,
    float tou = 0.0f,
    float sigma = 0.0f,
    float fixed_dt = 0.0f) {
  CudaMultiSphDataBuilder builder_(_fbb);
  builder_.add_fixed_dt(fixed_dt);
  builder_.add_sigma(sigma);
  builder_.add_tou(tou);
  builder_.add_gravity(gravity);
  builder_.add_bnu(bnu);
  builder_.add_sound_speed(sound_speed);
  builder_.add_stiff(stiff);
  builder_.add_particle_radius(particle_radius);
  builder_.add_kernel_radius(kernel_radius);
  builder_.add_visc0(visc0);
  builder_.add_color0(color0);
  builder_.add_mass0(mass0);
  builder_.add_rho0(rho0);
  builder_.add_phase_num(phase_num);
  builder_.add_miscible(miscible);
  return builder_.Finish();
}

inline flatbuffers::Offset<CudaMultiSphData> CreateCudaMultiSphDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t phase_num = 0,
    const std::vector<float> *rho0 = nullptr,
    const std::vector<float> *mass0 = nullptr,
    const std::vector<KIRI::FlatBuffers::float3> *color0 = nullptr,
    const std::vector<float> *visc0 = nullptr,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    float sound_speed = 0.0f,
    float bnu = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool miscible = false,
    float tou = 0.0f,
    float sigma = 0.0f,
    float fixed_dt = 0.0f) {
  auto rho0__ = rho0 ? _fbb.CreateVector<float>(*rho0) : 0;
  auto mass0__ = mass0 ? _fbb.CreateVector<float>(*mass0) : 0;
  auto color0__ = color0 ? _fbb.CreateVectorOfStructs<KIRI::FlatBuffers::float3>(*color0) : 0;
  auto visc0__ = visc0 ? _fbb.CreateVector<float>(*visc0) : 0;
  return KIRI::FlatBuffers::CreateCudaMultiSphData(
      _fbb,
      phase_num,
      rho0__,
      mass0__,
      color0__,
      visc0__,
      kernel_radius,
      particle_radius,
      stiff,
      sound_speed,
      bnu,
      gravity,
      miscible,
      tou,
      sigma,
      fixed_dt);
}

struct CudaMultiSphYan16Data FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaMultiSphYan16DataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PHASE_NUM = 4,
    VT_PHASE0 = 6,
    VT_RHO0 = 8,
    VT_MASS0 = 10,
    VT_COLOR0 = 12,
    VT_VISC0 = 14,
    VT_KERNEL_RADIUS = 16,
    VT_PARTICLE_RADIUS = 18,
    VT_STIFF = 20,
    VT_SOUND_SPEED = 22,
    VT_BNU = 24,
    VT_GRAVITY = 26,
    VT_MISCIBLE = 28,
    VT_TOU = 30,
    VT_SIGMA = 32,
    VT_YOUNG_MODULE = 34,
    VT_SHEAR_MODULE = 36,
    VT_FIXED_DT = 38
  };
  int32_t phase_num() const {
    return GetField<int32_t>(VT_PHASE_NUM, 0);
  }
  const flatbuffers::Vector<int32_t> *phase0() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PHASE0);
  }
  const flatbuffers::Vector<float> *rho0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RHO0);
  }
  const flatbuffers::Vector<float> *mass0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MASS0);
  }
  const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *color0() const {
    return GetPointer<const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *>(VT_COLOR0);
  }
  const flatbuffers::Vector<float> *visc0() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VISC0);
  }
  float kernel_radius() const {
    return GetField<float>(VT_KERNEL_RADIUS, 0.0f);
  }
  float particle_radius() const {
    return GetField<float>(VT_PARTICLE_RADIUS, 0.0f);
  }
  float stiff() const {
    return GetField<float>(VT_STIFF, 0.0f);
  }
  float sound_speed() const {
    return GetField<float>(VT_SOUND_SPEED, 0.0f);
  }
  float bnu() const {
    return GetField<float>(VT_BNU, 0.0f);
  }
  const KIRI::FlatBuffers::float3 *gravity() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_GRAVITY);
  }
  bool miscible() const {
    return GetField<uint8_t>(VT_MISCIBLE, 0) != 0;
  }
  float tou() const {
    return GetField<float>(VT_TOU, 0.0f);
  }
  float sigma() const {
    return GetField<float>(VT_SIGMA, 0.0f);
  }
  float young_module() const {
    return GetField<float>(VT_YOUNG_MODULE, 0.0f);
  }
  float shear_module() const {
    return GetField<float>(VT_SHEAR_MODULE, 0.0f);
  }
  float fixed_dt() const {
    return GetField<float>(VT_FIXED_DT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PHASE_NUM) &&
           VerifyOffset(verifier, VT_PHASE0) &&
           verifier.VerifyVector(phase0()) &&
           VerifyOffset(verifier, VT_RHO0) &&
           verifier.VerifyVector(rho0()) &&
           VerifyOffset(verifier, VT_MASS0) &&
           verifier.VerifyVector(mass0()) &&
           VerifyOffset(verifier, VT_COLOR0) &&
           verifier.VerifyVector(color0()) &&
           VerifyOffset(verifier, VT_VISC0) &&
           verifier.VerifyVector(visc0()) &&
           VerifyField<float>(verifier, VT_KERNEL_RADIUS) &&
           VerifyField<float>(verifier, VT_PARTICLE_RADIUS) &&
           VerifyField<float>(verifier, VT_STIFF) &&
           VerifyField<float>(verifier, VT_SOUND_SPEED) &&
           VerifyField<float>(verifier, VT_BNU) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_GRAVITY) &&
           VerifyField<uint8_t>(verifier, VT_MISCIBLE) &&
           VerifyField<float>(verifier, VT_TOU) &&
           VerifyField<float>(verifier, VT_SIGMA) &&
           VerifyField<float>(verifier, VT_YOUNG_MODULE) &&
           VerifyField<float>(verifier, VT_SHEAR_MODULE) &&
           VerifyField<float>(verifier, VT_FIXED_DT) &&
           verifier.EndTable();
  }
};

struct CudaMultiSphYan16DataBuilder {
  typedef CudaMultiSphYan16Data Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_phase_num(int32_t phase_num) {
    fbb_.AddElement<int32_t>(CudaMultiSphYan16Data::VT_PHASE_NUM, phase_num, 0);
  }
  void add_phase0(flatbuffers::Offset<flatbuffers::Vector<int32_t>> phase0) {
    fbb_.AddOffset(CudaMultiSphYan16Data::VT_PHASE0, phase0);
  }
  void add_rho0(flatbuffers::Offset<flatbuffers::Vector<float>> rho0) {
    fbb_.AddOffset(CudaMultiSphYan16Data::VT_RHO0, rho0);
  }
  void add_mass0(flatbuffers::Offset<flatbuffers::Vector<float>> mass0) {
    fbb_.AddOffset(CudaMultiSphYan16Data::VT_MASS0, mass0);
  }
  void add_color0(flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> color0) {
    fbb_.AddOffset(CudaMultiSphYan16Data::VT_COLOR0, color0);
  }
  void add_visc0(flatbuffers::Offset<flatbuffers::Vector<float>> visc0) {
    fbb_.AddOffset(CudaMultiSphYan16Data::VT_VISC0, visc0);
  }
  void add_kernel_radius(float kernel_radius) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_KERNEL_RADIUS, kernel_radius, 0.0f);
  }
  void add_particle_radius(float particle_radius) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_PARTICLE_RADIUS, particle_radius, 0.0f);
  }
  void add_stiff(float stiff) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_STIFF, stiff, 0.0f);
  }
  void add_sound_speed(float sound_speed) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_SOUND_SPEED, sound_speed, 0.0f);
  }
  void add_bnu(float bnu) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_BNU, bnu, 0.0f);
  }
  void add_gravity(const KIRI::FlatBuffers::float3 *gravity) {
    fbb_.AddStruct(CudaMultiSphYan16Data::VT_GRAVITY, gravity);
  }
  void add_miscible(bool miscible) {
    fbb_.AddElement<uint8_t>(CudaMultiSphYan16Data::VT_MISCIBLE, static_cast<uint8_t>(miscible), 0);
  }
  void add_tou(float tou) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_TOU, tou, 0.0f);
  }
  void add_sigma(float sigma) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_SIGMA, sigma, 0.0f);
  }
  void add_young_module(float young_module) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_YOUNG_MODULE, young_module, 0.0f);
  }
  void add_shear_module(float shear_module) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_SHEAR_MODULE, shear_module, 0.0f);
  }
  void add_fixed_dt(float fixed_dt) {
    fbb_.AddElement<float>(CudaMultiSphYan16Data::VT_FIXED_DT, fixed_dt, 0.0f);
  }
  explicit CudaMultiSphYan16DataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaMultiSphYan16Data> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaMultiSphYan16Data>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaMultiSphYan16Data> CreateCudaMultiSphYan16Data(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t phase_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> phase0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> rho0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> mass0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> color0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> visc0 = 0,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    float sound_speed = 0.0f,
    float bnu = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool miscible = false,
    float tou = 0.0f,
    float sigma = 0.0f,
    float young_module = 0.0f,
    float shear_module = 0.0f,
    float fixed_dt = 0.0f) {
  CudaMultiSphYan16DataBuilder builder_(_fbb);
  builder_.add_fixed_dt(fixed_dt);
  builder_.add_shear_module(shear_module);
  builder_.add_young_module(young_module);
  builder_.add_sigma(sigma);
  builder_.add_tou(tou);
  builder_.add_gravity(gravity);
  builder_.add_bnu(bnu);
  builder_.add_sound_speed(sound_speed);
  builder_.add_stiff(stiff);
  builder_.add_particle_radius(particle_radius);
  builder_.add_kernel_radius(kernel_radius);
  builder_.add_visc0(visc0);
  builder_.add_color0(color0);
  builder_.add_mass0(mass0);
  builder_.add_rho0(rho0);
  builder_.add_phase0(phase0);
  builder_.add_phase_num(phase_num);
  builder_.add_miscible(miscible);
  return builder_.Finish();
}

inline flatbuffers::Offset<CudaMultiSphYan16Data> CreateCudaMultiSphYan16DataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t phase_num = 0,
    const std::vector<int32_t> *phase0 = nullptr,
    const std::vector<float> *rho0 = nullptr,
    const std::vector<float> *mass0 = nullptr,
    const std::vector<KIRI::FlatBuffers::float3> *color0 = nullptr,
    const std::vector<float> *visc0 = nullptr,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    float sound_speed = 0.0f,
    float bnu = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool miscible = false,
    float tou = 0.0f,
    float sigma = 0.0f,
    float young_module = 0.0f,
    float shear_module = 0.0f,
    float fixed_dt = 0.0f) {
  auto phase0__ = phase0 ? _fbb.CreateVector<int32_t>(*phase0) : 0;
  auto rho0__ = rho0 ? _fbb.CreateVector<float>(*rho0) : 0;
  auto mass0__ = mass0 ? _fbb.CreateVector<float>(*mass0) : 0;
  auto color0__ = color0 ? _fbb.CreateVectorOfStructs<KIRI::FlatBuffers::float3>(*color0) : 0;
  auto visc0__ = visc0 ? _fbb.CreateVector<float>(*visc0) : 0;
  return KIRI::FlatBuffers::CreateCudaMultiSphYan16Data(
      _fbb,
      phase_num,
      phase0__,
      rho0__,
      mass0__,
      color0__,
      visc0__,
      kernel_radius,
      particle_radius,
      stiff,
      sound_speed,
      bnu,
      gravity,
      miscible,
      tou,
      sigma,
      young_module,
      shear_module,
      fixed_dt);
}

}  // namespace FlatBuffers
}  // namespace KIRI

#endif  // FLATBUFFERS_GENERATED_CUDAMULTISPHDATA_KIRI_FLATBUFFERS_H_
