// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SPHDATA_KIRI_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_SPHDATA_KIRI_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "basic_types_generated.h"

namespace KIRI {
namespace FlatBuffers {

struct SphBoxEmitter;
struct SphBoxEmitterBuilder;

struct SphDynamicEmitterPDS;
struct SphDynamicEmitterPDSBuilder;

struct PolyData;
struct PolyDataBuilder;

struct SphData;
struct SphDataBuilder;

struct SphBoxEmitter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphBoxEmitterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOX_LOWER = 4,
    VT_BOX_SIZE = 6,
    VT_BOX_COLOR = 8
  };
  const KIRI::FlatBuffers::float3 *box_lower() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_LOWER);
  }
  const KIRI::FlatBuffers::int3 *box_size() const {
    return GetStruct<const KIRI::FlatBuffers::int3 *>(VT_BOX_SIZE);
  }
  const KIRI::FlatBuffers::float3 *box_color() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_LOWER) &&
           VerifyField<KIRI::FlatBuffers::int3>(verifier, VT_BOX_SIZE) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_COLOR) &&
           verifier.EndTable();
  }
};

struct SphBoxEmitterBuilder {
  typedef SphBoxEmitter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_box_lower(const KIRI::FlatBuffers::float3 *box_lower) {
    fbb_.AddStruct(SphBoxEmitter::VT_BOX_LOWER, box_lower);
  }
  void add_box_size(const KIRI::FlatBuffers::int3 *box_size) {
    fbb_.AddStruct(SphBoxEmitter::VT_BOX_SIZE, box_size);
  }
  void add_box_color(const KIRI::FlatBuffers::float3 *box_color) {
    fbb_.AddStruct(SphBoxEmitter::VT_BOX_COLOR, box_color);
  }
  explicit SphBoxEmitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphBoxEmitter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphBoxEmitter>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphBoxEmitter> CreateSphBoxEmitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    const KIRI::FlatBuffers::float3 *box_lower = 0,
    const KIRI::FlatBuffers::int3 *box_size = 0,
    const KIRI::FlatBuffers::float3 *box_color = 0) {
  SphBoxEmitterBuilder builder_(_fbb);
  builder_.add_box_color(box_color);
  builder_.add_box_size(box_size);
  builder_.add_box_lower(box_lower);
  return builder_.Finish();
}

struct SphDynamicEmitterPDS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphDynamicEmitterPDSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUARE_SHAPED_EMITTER = 4,
    VT_CUSTOM_DEFINE = 6,
    VT_EMIT_RADIUS = 8,
    VT_EMIT_WIDTH = 10,
    VT_EMIT_HEIGHT = 12,
    VT_POSITION = 14,
    VT_VELOCITY = 16
  };
  bool square_shaped_emitter() const {
    return GetField<uint8_t>(VT_SQUARE_SHAPED_EMITTER, 0) != 0;
  }
  bool custom_define() const {
    return GetField<uint8_t>(VT_CUSTOM_DEFINE, 0) != 0;
  }
  float emit_radius() const {
    return GetField<float>(VT_EMIT_RADIUS, 0.0f);
  }
  float emit_width() const {
    return GetField<float>(VT_EMIT_WIDTH, 0.0f);
  }
  float emit_height() const {
    return GetField<float>(VT_EMIT_HEIGHT, 0.0f);
  }
  const KIRI::FlatBuffers::float3 *position() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_POSITION);
  }
  const KIRI::FlatBuffers::float3 *velocity() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SQUARE_SHAPED_EMITTER) &&
           VerifyField<uint8_t>(verifier, VT_CUSTOM_DEFINE) &&
           VerifyField<float>(verifier, VT_EMIT_RADIUS) &&
           VerifyField<float>(verifier, VT_EMIT_WIDTH) &&
           VerifyField<float>(verifier, VT_EMIT_HEIGHT) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_POSITION) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
};

struct SphDynamicEmitterPDSBuilder {
  typedef SphDynamicEmitterPDS Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_square_shaped_emitter(bool square_shaped_emitter) {
    fbb_.AddElement<uint8_t>(SphDynamicEmitterPDS::VT_SQUARE_SHAPED_EMITTER, static_cast<uint8_t>(square_shaped_emitter), 0);
  }
  void add_custom_define(bool custom_define) {
    fbb_.AddElement<uint8_t>(SphDynamicEmitterPDS::VT_CUSTOM_DEFINE, static_cast<uint8_t>(custom_define), 0);
  }
  void add_emit_radius(float emit_radius) {
    fbb_.AddElement<float>(SphDynamicEmitterPDS::VT_EMIT_RADIUS, emit_radius, 0.0f);
  }
  void add_emit_width(float emit_width) {
    fbb_.AddElement<float>(SphDynamicEmitterPDS::VT_EMIT_WIDTH, emit_width, 0.0f);
  }
  void add_emit_height(float emit_height) {
    fbb_.AddElement<float>(SphDynamicEmitterPDS::VT_EMIT_HEIGHT, emit_height, 0.0f);
  }
  void add_position(const KIRI::FlatBuffers::float3 *position) {
    fbb_.AddStruct(SphDynamicEmitterPDS::VT_POSITION, position);
  }
  void add_velocity(const KIRI::FlatBuffers::float3 *velocity) {
    fbb_.AddStruct(SphDynamicEmitterPDS::VT_VELOCITY, velocity);
  }
  explicit SphDynamicEmitterPDSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphDynamicEmitterPDS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphDynamicEmitterPDS>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphDynamicEmitterPDS> CreateSphDynamicEmitterPDS(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool square_shaped_emitter = false,
    bool custom_define = false,
    float emit_radius = 0.0f,
    float emit_width = 0.0f,
    float emit_height = 0.0f,
    const KIRI::FlatBuffers::float3 *position = 0,
    const KIRI::FlatBuffers::float3 *velocity = 0) {
  SphDynamicEmitterPDSBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_emit_height(emit_height);
  builder_.add_emit_width(emit_width);
  builder_.add_emit_radius(emit_radius);
  builder_.add_custom_define(custom_define);
  builder_.add_square_shaped_emitter(square_shaped_emitter);
  return builder_.Finish();
}

struct PolyData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_NAME = 4,
    VT_OFFSET = 6,
    VT_SCALE = 8
  };
  const flatbuffers::String *model_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAME);
  }
  const KIRI::FlatBuffers::float3 *offset() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_OFFSET);
  }
  const KIRI::FlatBuffers::float3 *scale() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_OFFSET) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct PolyDataBuilder {
  typedef PolyData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_model_name(flatbuffers::Offset<flatbuffers::String> model_name) {
    fbb_.AddOffset(PolyData::VT_MODEL_NAME, model_name);
  }
  void add_offset(const KIRI::FlatBuffers::float3 *offset) {
    fbb_.AddStruct(PolyData::VT_OFFSET, offset);
  }
  void add_scale(const KIRI::FlatBuffers::float3 *scale) {
    fbb_.AddStruct(PolyData::VT_SCALE, scale);
  }
  explicit PolyDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PolyData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolyData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolyData> CreatePolyData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> model_name = 0,
    const KIRI::FlatBuffers::float3 *offset = 0,
    const KIRI::FlatBuffers::float3 *scale = 0) {
  PolyDataBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_offset(offset);
  builder_.add_model_name(model_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PolyData> CreatePolyDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *model_name = nullptr,
    const KIRI::FlatBuffers::float3 *offset = 0,
    const KIRI::FlatBuffers::float3 *scale = 0) {
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  return KIRI::FlatBuffers::CreatePolyData(
      _fbb,
      model_name__,
      offset,
      scale);
}

struct SphData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REST_DENSITY = 4,
    VT_REST_MASS = 6,
    VT_KERNEL_RADIUS = 8,
    VT_PARTICLE_RADIUS = 10,
    VT_COEF_KAPPA = 12,
    VT_COEF_VISCOSITY = 14,
    VT_POLY_SEARCHER = 16,
    VT_POLY_DATA = 18,
    VT_VISIABLE = 20
  };
  float rest_density() const {
    return GetField<float>(VT_REST_DENSITY, 0.0f);
  }
  float rest_mass() const {
    return GetField<float>(VT_REST_MASS, 0.0f);
  }
  float kernel_radius() const {
    return GetField<float>(VT_KERNEL_RADIUS, 0.0f);
  }
  float particle_radius() const {
    return GetField<float>(VT_PARTICLE_RADIUS, 0.0f);
  }
  float coef_kappa() const {
    return GetField<float>(VT_COEF_KAPPA, 0.0f);
  }
  float coef_viscosity() const {
    return GetField<float>(VT_COEF_VISCOSITY, 0.0f);
  }
  bool poly_searcher() const {
    return GetField<uint8_t>(VT_POLY_SEARCHER, 0) != 0;
  }
  const KIRI::FlatBuffers::PolyData *poly_data() const {
    return GetPointer<const KIRI::FlatBuffers::PolyData *>(VT_POLY_DATA);
  }
  bool visiable() const {
    return GetField<uint8_t>(VT_VISIABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_REST_DENSITY) &&
           VerifyField<float>(verifier, VT_REST_MASS) &&
           VerifyField<float>(verifier, VT_KERNEL_RADIUS) &&
           VerifyField<float>(verifier, VT_PARTICLE_RADIUS) &&
           VerifyField<float>(verifier, VT_COEF_KAPPA) &&
           VerifyField<float>(verifier, VT_COEF_VISCOSITY) &&
           VerifyField<uint8_t>(verifier, VT_POLY_SEARCHER) &&
           VerifyOffset(verifier, VT_POLY_DATA) &&
           verifier.VerifyTable(poly_data()) &&
           VerifyField<uint8_t>(verifier, VT_VISIABLE) &&
           verifier.EndTable();
  }
};

struct SphDataBuilder {
  typedef SphData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rest_density(float rest_density) {
    fbb_.AddElement<float>(SphData::VT_REST_DENSITY, rest_density, 0.0f);
  }
  void add_rest_mass(float rest_mass) {
    fbb_.AddElement<float>(SphData::VT_REST_MASS, rest_mass, 0.0f);
  }
  void add_kernel_radius(float kernel_radius) {
    fbb_.AddElement<float>(SphData::VT_KERNEL_RADIUS, kernel_radius, 0.0f);
  }
  void add_particle_radius(float particle_radius) {
    fbb_.AddElement<float>(SphData::VT_PARTICLE_RADIUS, particle_radius, 0.0f);
  }
  void add_coef_kappa(float coef_kappa) {
    fbb_.AddElement<float>(SphData::VT_COEF_KAPPA, coef_kappa, 0.0f);
  }
  void add_coef_viscosity(float coef_viscosity) {
    fbb_.AddElement<float>(SphData::VT_COEF_VISCOSITY, coef_viscosity, 0.0f);
  }
  void add_poly_searcher(bool poly_searcher) {
    fbb_.AddElement<uint8_t>(SphData::VT_POLY_SEARCHER, static_cast<uint8_t>(poly_searcher), 0);
  }
  void add_poly_data(flatbuffers::Offset<KIRI::FlatBuffers::PolyData> poly_data) {
    fbb_.AddOffset(SphData::VT_POLY_DATA, poly_data);
  }
  void add_visiable(bool visiable) {
    fbb_.AddElement<uint8_t>(SphData::VT_VISIABLE, static_cast<uint8_t>(visiable), 0);
  }
  explicit SphDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphData>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphData> CreateSphData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rest_density = 0.0f,
    float rest_mass = 0.0f,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float coef_kappa = 0.0f,
    float coef_viscosity = 0.0f,
    bool poly_searcher = false,
    flatbuffers::Offset<KIRI::FlatBuffers::PolyData> poly_data = 0,
    bool visiable = false) {
  SphDataBuilder builder_(_fbb);
  builder_.add_poly_data(poly_data);
  builder_.add_coef_viscosity(coef_viscosity);
  builder_.add_coef_kappa(coef_kappa);
  builder_.add_particle_radius(particle_radius);
  builder_.add_kernel_radius(kernel_radius);
  builder_.add_rest_mass(rest_mass);
  builder_.add_rest_density(rest_density);
  builder_.add_visiable(visiable);
  builder_.add_poly_searcher(poly_searcher);
  return builder_.Finish();
}

}  // namespace FlatBuffers
}  // namespace KIRI

#endif  // FLATBUFFERS_GENERATED_SPHDATA_KIRI_FLATBUFFERS_H_
