// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CUDASEEPAGEFLOWAPP_KIRI_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CUDASEEPAGEFLOWAPP_KIRI_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "app_data_generated.h"
#include "basic_types_generated.h"
#include "cuda_dem_data_generated.h"
#include "cuda_seepageflow_data_generated.h"
#include "cuda_sph_data_generated.h"
#include "renderer_data_generated.h"

namespace KIRI {
namespace FlatBuffers {

struct BoundaryShapeVolumes;
struct BoundaryShapeVolumesBuilder;

struct CudaSeepageFlowApp;
struct CudaSeepageFlowAppBuilder;

enum CudaSeepageflowType {
  CudaSeepageflowType_SF = 0,
  CudaSeepageflowType_MULTI_SF = 1,
  CudaSeepageflowType_MIN = CudaSeepageflowType_SF,
  CudaSeepageflowType_MAX = CudaSeepageflowType_MULTI_SF
};

inline const CudaSeepageflowType (&EnumValuesCudaSeepageflowType())[2] {
  static const CudaSeepageflowType values[] = {
    CudaSeepageflowType_SF,
    CudaSeepageflowType_MULTI_SF
  };
  return values;
}

inline const char * const *EnumNamesCudaSeepageflowType() {
  static const char * const names[3] = {
    "SF",
    "MULTI_SF",
    nullptr
  };
  return names;
}

inline const char *EnumNameCudaSeepageflowType(CudaSeepageflowType e) {
  if (flatbuffers::IsOutRange(e, CudaSeepageflowType_SF, CudaSeepageflowType_MULTI_SF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCudaSeepageflowType()[index];
}

struct BoundaryShapeVolumes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoundaryShapeVolumesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FOLDERS = 4,
    VT_FILES = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *folders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FOLDERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FOLDERS) &&
           verifier.VerifyVector(folders()) &&
           verifier.VerifyVectorOfStrings(folders()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
};

struct BoundaryShapeVolumesBuilder {
  typedef BoundaryShapeVolumes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_folders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> folders) {
    fbb_.AddOffset(BoundaryShapeVolumes::VT_FOLDERS, folders);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(BoundaryShapeVolumes::VT_FILES, files);
  }
  explicit BoundaryShapeVolumesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoundaryShapeVolumes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoundaryShapeVolumes>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoundaryShapeVolumes> CreateBoundaryShapeVolumes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> folders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  BoundaryShapeVolumesBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_folders(folders);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoundaryShapeVolumes> CreateBoundaryShapeVolumesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *folders = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  auto folders__ = folders ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*folders) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  return KIRI::FlatBuffers::CreateBoundaryShapeVolumes(
      _fbb,
      folders__,
      files__);
}

struct CudaSeepageFlowApp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaSeepageFlowAppBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WATER_BOX_VOLUME = 4,
    VT_SAND_BOX_VOLUME = 6,
    VT_SAND_SHAPE_VOLUME = 8,
    VT_BOUNDARY_SHAPE_VOLUME = 10,
    VT_SPH_SOLVER_TYPE = 12,
    VT_SPH_EMITTER = 14,
    VT_SEEPAGE_FLOW_TYPE = 16,
    VT_SEEPAGE_FLOW_CDA0ASAT = 18,
    VT_SEEPAGE_FLOW_AMCAMCP = 20,
    VT_SEEPAGE_FLOW_DATA = 22,
    VT_MAX_PARTICLES_NUM = 24,
    VT_APP_DATA = 26,
    VT_RENDERER_DATA = 28
  };
  const KIRI::FlatBuffers::SphInitBoxVolume *water_box_volume() const {
    return GetPointer<const KIRI::FlatBuffers::SphInitBoxVolume *>(VT_WATER_BOX_VOLUME);
  }
  const KIRI::FlatBuffers::DemInitBoxVolume *sand_box_volume() const {
    return GetPointer<const KIRI::FlatBuffers::DemInitBoxVolume *>(VT_SAND_BOX_VOLUME);
  }
  const KIRI::FlatBuffers::DemShapeVolumes *sand_shape_volume() const {
    return GetPointer<const KIRI::FlatBuffers::DemShapeVolumes *>(VT_SAND_SHAPE_VOLUME);
  }
  const KIRI::FlatBuffers::BoundaryShapeVolumes *boundary_shape_volume() const {
    return GetPointer<const KIRI::FlatBuffers::BoundaryShapeVolumes *>(VT_BOUNDARY_SHAPE_VOLUME);
  }
  KIRI::FlatBuffers::CudaSphType sph_solver_type() const {
    return static_cast<KIRI::FlatBuffers::CudaSphType>(GetField<int8_t>(VT_SPH_SOLVER_TYPE, 0));
  }
  const KIRI::FlatBuffers::CudaSphEmitter *sph_emitter() const {
    return GetPointer<const KIRI::FlatBuffers::CudaSphEmitter *>(VT_SPH_EMITTER);
  }
  KIRI::FlatBuffers::CudaSeepageflowType seepage_flow_type() const {
    return static_cast<KIRI::FlatBuffers::CudaSeepageflowType>(GetField<int8_t>(VT_SEEPAGE_FLOW_TYPE, 0));
  }
  const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *seepage_flow_cda0asat() const {
    return GetPointer<const flatbuffers::Vector<const KIRI::FlatBuffers::float3 *> *>(VT_SEEPAGE_FLOW_CDA0ASAT);
  }
  const flatbuffers::Vector<const KIRI::FlatBuffers::float2 *> *seepage_flow_amcamcp() const {
    return GetPointer<const flatbuffers::Vector<const KIRI::FlatBuffers::float2 *> *>(VT_SEEPAGE_FLOW_AMCAMCP);
  }
  const KIRI::FlatBuffers::CudaSeepageFlowData *seepage_flow_data() const {
    return GetPointer<const KIRI::FlatBuffers::CudaSeepageFlowData *>(VT_SEEPAGE_FLOW_DATA);
  }
  uint32_t max_particles_num() const {
    return GetField<uint32_t>(VT_MAX_PARTICLES_NUM, 0);
  }
  const KIRI::FlatBuffers::AppData *app_data() const {
    return GetPointer<const KIRI::FlatBuffers::AppData *>(VT_APP_DATA);
  }
  const KIRI::FlatBuffers::SSFData *renderer_data() const {
    return GetPointer<const KIRI::FlatBuffers::SSFData *>(VT_RENDERER_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WATER_BOX_VOLUME) &&
           verifier.VerifyTable(water_box_volume()) &&
           VerifyOffset(verifier, VT_SAND_BOX_VOLUME) &&
           verifier.VerifyTable(sand_box_volume()) &&
           VerifyOffset(verifier, VT_SAND_SHAPE_VOLUME) &&
           verifier.VerifyTable(sand_shape_volume()) &&
           VerifyOffset(verifier, VT_BOUNDARY_SHAPE_VOLUME) &&
           verifier.VerifyTable(boundary_shape_volume()) &&
           VerifyField<int8_t>(verifier, VT_SPH_SOLVER_TYPE) &&
           VerifyOffset(verifier, VT_SPH_EMITTER) &&
           verifier.VerifyTable(sph_emitter()) &&
           VerifyField<int8_t>(verifier, VT_SEEPAGE_FLOW_TYPE) &&
           VerifyOffset(verifier, VT_SEEPAGE_FLOW_CDA0ASAT) &&
           verifier.VerifyVector(seepage_flow_cda0asat()) &&
           VerifyOffset(verifier, VT_SEEPAGE_FLOW_AMCAMCP) &&
           verifier.VerifyVector(seepage_flow_amcamcp()) &&
           VerifyOffset(verifier, VT_SEEPAGE_FLOW_DATA) &&
           verifier.VerifyTable(seepage_flow_data()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_PARTICLES_NUM) &&
           VerifyOffset(verifier, VT_APP_DATA) &&
           verifier.VerifyTable(app_data()) &&
           VerifyOffset(verifier, VT_RENDERER_DATA) &&
           verifier.VerifyTable(renderer_data()) &&
           verifier.EndTable();
  }
};

struct CudaSeepageFlowAppBuilder {
  typedef CudaSeepageFlowApp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_water_box_volume(flatbuffers::Offset<KIRI::FlatBuffers::SphInitBoxVolume> water_box_volume) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_WATER_BOX_VOLUME, water_box_volume);
  }
  void add_sand_box_volume(flatbuffers::Offset<KIRI::FlatBuffers::DemInitBoxVolume> sand_box_volume) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SAND_BOX_VOLUME, sand_box_volume);
  }
  void add_sand_shape_volume(flatbuffers::Offset<KIRI::FlatBuffers::DemShapeVolumes> sand_shape_volume) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SAND_SHAPE_VOLUME, sand_shape_volume);
  }
  void add_boundary_shape_volume(flatbuffers::Offset<KIRI::FlatBuffers::BoundaryShapeVolumes> boundary_shape_volume) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_BOUNDARY_SHAPE_VOLUME, boundary_shape_volume);
  }
  void add_sph_solver_type(KIRI::FlatBuffers::CudaSphType sph_solver_type) {
    fbb_.AddElement<int8_t>(CudaSeepageFlowApp::VT_SPH_SOLVER_TYPE, static_cast<int8_t>(sph_solver_type), 0);
  }
  void add_sph_emitter(flatbuffers::Offset<KIRI::FlatBuffers::CudaSphEmitter> sph_emitter) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SPH_EMITTER, sph_emitter);
  }
  void add_seepage_flow_type(KIRI::FlatBuffers::CudaSeepageflowType seepage_flow_type) {
    fbb_.AddElement<int8_t>(CudaSeepageFlowApp::VT_SEEPAGE_FLOW_TYPE, static_cast<int8_t>(seepage_flow_type), 0);
  }
  void add_seepage_flow_cda0asat(flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> seepage_flow_cda0asat) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SEEPAGE_FLOW_CDA0ASAT, seepage_flow_cda0asat);
  }
  void add_seepage_flow_amcamcp(flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float2 *>> seepage_flow_amcamcp) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SEEPAGE_FLOW_AMCAMCP, seepage_flow_amcamcp);
  }
  void add_seepage_flow_data(flatbuffers::Offset<KIRI::FlatBuffers::CudaSeepageFlowData> seepage_flow_data) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_SEEPAGE_FLOW_DATA, seepage_flow_data);
  }
  void add_max_particles_num(uint32_t max_particles_num) {
    fbb_.AddElement<uint32_t>(CudaSeepageFlowApp::VT_MAX_PARTICLES_NUM, max_particles_num, 0);
  }
  void add_app_data(flatbuffers::Offset<KIRI::FlatBuffers::AppData> app_data) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_APP_DATA, app_data);
  }
  void add_renderer_data(flatbuffers::Offset<KIRI::FlatBuffers::SSFData> renderer_data) {
    fbb_.AddOffset(CudaSeepageFlowApp::VT_RENDERER_DATA, renderer_data);
  }
  explicit CudaSeepageFlowAppBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaSeepageFlowApp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaSeepageFlowApp>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaSeepageFlowApp> CreateCudaSeepageFlowApp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<KIRI::FlatBuffers::SphInitBoxVolume> water_box_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::DemInitBoxVolume> sand_box_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::DemShapeVolumes> sand_shape_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::BoundaryShapeVolumes> boundary_shape_volume = 0,
    KIRI::FlatBuffers::CudaSphType sph_solver_type = KIRI::FlatBuffers::CudaSphType_SPH,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSphEmitter> sph_emitter = 0,
    KIRI::FlatBuffers::CudaSeepageflowType seepage_flow_type = KIRI::FlatBuffers::CudaSeepageflowType_SF,
    flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float3 *>> seepage_flow_cda0asat = 0,
    flatbuffers::Offset<flatbuffers::Vector<const KIRI::FlatBuffers::float2 *>> seepage_flow_amcamcp = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSeepageFlowData> seepage_flow_data = 0,
    uint32_t max_particles_num = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::AppData> app_data = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::SSFData> renderer_data = 0) {
  CudaSeepageFlowAppBuilder builder_(_fbb);
  builder_.add_renderer_data(renderer_data);
  builder_.add_app_data(app_data);
  builder_.add_max_particles_num(max_particles_num);
  builder_.add_seepage_flow_data(seepage_flow_data);
  builder_.add_seepage_flow_amcamcp(seepage_flow_amcamcp);
  builder_.add_seepage_flow_cda0asat(seepage_flow_cda0asat);
  builder_.add_sph_emitter(sph_emitter);
  builder_.add_boundary_shape_volume(boundary_shape_volume);
  builder_.add_sand_shape_volume(sand_shape_volume);
  builder_.add_sand_box_volume(sand_box_volume);
  builder_.add_water_box_volume(water_box_volume);
  builder_.add_seepage_flow_type(seepage_flow_type);
  builder_.add_sph_solver_type(sph_solver_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CudaSeepageFlowApp> CreateCudaSeepageFlowAppDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<KIRI::FlatBuffers::SphInitBoxVolume> water_box_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::DemInitBoxVolume> sand_box_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::DemShapeVolumes> sand_shape_volume = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::BoundaryShapeVolumes> boundary_shape_volume = 0,
    KIRI::FlatBuffers::CudaSphType sph_solver_type = KIRI::FlatBuffers::CudaSphType_SPH,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSphEmitter> sph_emitter = 0,
    KIRI::FlatBuffers::CudaSeepageflowType seepage_flow_type = KIRI::FlatBuffers::CudaSeepageflowType_SF,
    const std::vector<KIRI::FlatBuffers::float3> *seepage_flow_cda0asat = nullptr,
    const std::vector<KIRI::FlatBuffers::float2> *seepage_flow_amcamcp = nullptr,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSeepageFlowData> seepage_flow_data = 0,
    uint32_t max_particles_num = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::AppData> app_data = 0,
    flatbuffers::Offset<KIRI::FlatBuffers::SSFData> renderer_data = 0) {
  auto seepage_flow_cda0asat__ = seepage_flow_cda0asat ? _fbb.CreateVectorOfStructs<KIRI::FlatBuffers::float3>(*seepage_flow_cda0asat) : 0;
  auto seepage_flow_amcamcp__ = seepage_flow_amcamcp ? _fbb.CreateVectorOfStructs<KIRI::FlatBuffers::float2>(*seepage_flow_amcamcp) : 0;
  return KIRI::FlatBuffers::CreateCudaSeepageFlowApp(
      _fbb,
      water_box_volume,
      sand_box_volume,
      sand_shape_volume,
      boundary_shape_volume,
      sph_solver_type,
      sph_emitter,
      seepage_flow_type,
      seepage_flow_cda0asat__,
      seepage_flow_amcamcp__,
      seepage_flow_data,
      max_particles_num,
      app_data,
      renderer_data);
}

inline const KIRI::FlatBuffers::CudaSeepageFlowApp *GetCudaSeepageFlowApp(const void *buf) {
  return flatbuffers::GetRoot<KIRI::FlatBuffers::CudaSeepageFlowApp>(buf);
}

inline const KIRI::FlatBuffers::CudaSeepageFlowApp *GetSizePrefixedCudaSeepageFlowApp(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<KIRI::FlatBuffers::CudaSeepageFlowApp>(buf);
}

inline bool VerifyCudaSeepageFlowAppBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<KIRI::FlatBuffers::CudaSeepageFlowApp>(nullptr);
}

inline bool VerifySizePrefixedCudaSeepageFlowAppBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<KIRI::FlatBuffers::CudaSeepageFlowApp>(nullptr);
}

inline void FinishCudaSeepageFlowAppBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSeepageFlowApp> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCudaSeepageFlowAppBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<KIRI::FlatBuffers::CudaSeepageFlowApp> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatBuffers
}  // namespace KIRI

#endif  // FLATBUFFERS_GENERATED_CUDASEEPAGEFLOWAPP_KIRI_FLATBUFFERS_H_
