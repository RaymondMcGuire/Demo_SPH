// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "basic_types_generated.h"

namespace KIRI {
namespace FlatBuffers {

struct SphInitBoxVolume;
struct SphInitBoxVolumeBuilder;

struct CudaSphData;
struct CudaSphDataBuilder;

struct CudaSphEmitter;
struct CudaSphEmitterBuilder;

enum CudaSphType {
  CudaSphType_SPH = 0,
  CudaSphType_WCSPH = 1,
  CudaSphType_IISPH = 2,
  CudaSphType_DFSPH = 3,
  CudaSphType_PBF = 4,
  CudaSphType_MSSPH = 5,
  CudaSphType_MIN = CudaSphType_SPH,
  CudaSphType_MAX = CudaSphType_MSSPH
};

inline const CudaSphType (&EnumValuesCudaSphType())[6] {
  static const CudaSphType values[] = {
    CudaSphType_SPH,
    CudaSphType_WCSPH,
    CudaSphType_IISPH,
    CudaSphType_DFSPH,
    CudaSphType_PBF,
    CudaSphType_MSSPH
  };
  return values;
}

inline const char * const *EnumNamesCudaSphType() {
  static const char * const names[7] = {
    "SPH",
    "WCSPH",
    "IISPH",
    "DFSPH",
    "PBF",
    "MSSPH",
    nullptr
  };
  return names;
}

inline const char *EnumNameCudaSphType(CudaSphType e) {
  if (flatbuffers::IsOutRange(e, CudaSphType_SPH, CudaSphType_MSSPH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCudaSphType()[index];
}

enum CudaSphEmitterType {
  CudaSphEmitterType_SQUARE = 0,
  CudaSphEmitterType_CIRCLE = 1,
  CudaSphEmitterType_RECTANGLE = 2,
  CudaSphEmitterType_MIN = CudaSphEmitterType_SQUARE,
  CudaSphEmitterType_MAX = CudaSphEmitterType_RECTANGLE
};

inline const CudaSphEmitterType (&EnumValuesCudaSphEmitterType())[3] {
  static const CudaSphEmitterType values[] = {
    CudaSphEmitterType_SQUARE,
    CudaSphEmitterType_CIRCLE,
    CudaSphEmitterType_RECTANGLE
  };
  return values;
}

inline const char * const *EnumNamesCudaSphEmitterType() {
  static const char * const names[4] = {
    "SQUARE",
    "CIRCLE",
    "RECTANGLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCudaSphEmitterType(CudaSphEmitterType e) {
  if (flatbuffers::IsOutRange(e, CudaSphEmitterType_SQUARE, CudaSphEmitterType_RECTANGLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCudaSphEmitterType()[index];
}

struct SphInitBoxVolume FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SphInitBoxVolumeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOX_LOWER = 4,
    VT_BOX_SIZE = 6,
    VT_BOX_COLOR = 8
  };
  const KIRI::FlatBuffers::float3 *box_lower() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_LOWER);
  }
  const KIRI::FlatBuffers::int3 *box_size() const {
    return GetStruct<const KIRI::FlatBuffers::int3 *>(VT_BOX_SIZE);
  }
  const KIRI::FlatBuffers::float3 *box_color() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_BOX_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_LOWER) &&
           VerifyField<KIRI::FlatBuffers::int3>(verifier, VT_BOX_SIZE) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_BOX_COLOR) &&
           verifier.EndTable();
  }
};

struct SphInitBoxVolumeBuilder {
  typedef SphInitBoxVolume Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_box_lower(const KIRI::FlatBuffers::float3 *box_lower) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_LOWER, box_lower);
  }
  void add_box_size(const KIRI::FlatBuffers::int3 *box_size) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_SIZE, box_size);
  }
  void add_box_color(const KIRI::FlatBuffers::float3 *box_color) {
    fbb_.AddStruct(SphInitBoxVolume::VT_BOX_COLOR, box_color);
  }
  explicit SphInitBoxVolumeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SphInitBoxVolume> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphInitBoxVolume>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphInitBoxVolume> CreateSphInitBoxVolume(
    flatbuffers::FlatBufferBuilder &_fbb,
    const KIRI::FlatBuffers::float3 *box_lower = 0,
    const KIRI::FlatBuffers::int3 *box_size = 0,
    const KIRI::FlatBuffers::float3 *box_color = 0) {
  SphInitBoxVolumeBuilder builder_(_fbb);
  builder_.add_box_color(box_color);
  builder_.add_box_size(box_size);
  builder_.add_box_lower(box_lower);
  return builder_.Finish();
}

struct CudaSphData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaSphDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REST_DENSITY = 4,
    VT_REST_MASS = 6,
    VT_KERNEL_RADIUS = 8,
    VT_PARTICLE_RADIUS = 10,
    VT_STIFF = 12,
    VT_GRAVITY = 14,
    VT_ENABLE_ATF_VISC = 16,
    VT_VISC = 18,
    VT_NU = 20,
    VT_BNU = 22,
    VT_ENABLE_STA_AKINCI13 = 24,
    VT_ST_GAMMA = 26,
    VT_A_BETA = 28,
    VT_FIXED_DT = 30
  };
  float rest_density() const {
    return GetField<float>(VT_REST_DENSITY, 0.0f);
  }
  float rest_mass() const {
    return GetField<float>(VT_REST_MASS, 0.0f);
  }
  float kernel_radius() const {
    return GetField<float>(VT_KERNEL_RADIUS, 0.0f);
  }
  float particle_radius() const {
    return GetField<float>(VT_PARTICLE_RADIUS, 0.0f);
  }
  float stiff() const {
    return GetField<float>(VT_STIFF, 0.0f);
  }
  const KIRI::FlatBuffers::float3 *gravity() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_GRAVITY);
  }
  bool enable_atf_visc() const {
    return GetField<uint8_t>(VT_ENABLE_ATF_VISC, 0) != 0;
  }
  float visc() const {
    return GetField<float>(VT_VISC, 0.0f);
  }
  float nu() const {
    return GetField<float>(VT_NU, 0.0f);
  }
  float bnu() const {
    return GetField<float>(VT_BNU, 0.0f);
  }
  bool enable_sta_akinci13() const {
    return GetField<uint8_t>(VT_ENABLE_STA_AKINCI13, 0) != 0;
  }
  float st_gamma() const {
    return GetField<float>(VT_ST_GAMMA, 1.0f);
  }
  float a_beta() const {
    return GetField<float>(VT_A_BETA, 1.0f);
  }
  float fixed_dt() const {
    return GetField<float>(VT_FIXED_DT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_REST_DENSITY) &&
           VerifyField<float>(verifier, VT_REST_MASS) &&
           VerifyField<float>(verifier, VT_KERNEL_RADIUS) &&
           VerifyField<float>(verifier, VT_PARTICLE_RADIUS) &&
           VerifyField<float>(verifier, VT_STIFF) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_GRAVITY) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_ATF_VISC) &&
           VerifyField<float>(verifier, VT_VISC) &&
           VerifyField<float>(verifier, VT_NU) &&
           VerifyField<float>(verifier, VT_BNU) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE_STA_AKINCI13) &&
           VerifyField<float>(verifier, VT_ST_GAMMA) &&
           VerifyField<float>(verifier, VT_A_BETA) &&
           VerifyField<float>(verifier, VT_FIXED_DT) &&
           verifier.EndTable();
  }
};

struct CudaSphDataBuilder {
  typedef CudaSphData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rest_density(float rest_density) {
    fbb_.AddElement<float>(CudaSphData::VT_REST_DENSITY, rest_density, 0.0f);
  }
  void add_rest_mass(float rest_mass) {
    fbb_.AddElement<float>(CudaSphData::VT_REST_MASS, rest_mass, 0.0f);
  }
  void add_kernel_radius(float kernel_radius) {
    fbb_.AddElement<float>(CudaSphData::VT_KERNEL_RADIUS, kernel_radius, 0.0f);
  }
  void add_particle_radius(float particle_radius) {
    fbb_.AddElement<float>(CudaSphData::VT_PARTICLE_RADIUS, particle_radius, 0.0f);
  }
  void add_stiff(float stiff) {
    fbb_.AddElement<float>(CudaSphData::VT_STIFF, stiff, 0.0f);
  }
  void add_gravity(const KIRI::FlatBuffers::float3 *gravity) {
    fbb_.AddStruct(CudaSphData::VT_GRAVITY, gravity);
  }
  void add_enable_atf_visc(bool enable_atf_visc) {
    fbb_.AddElement<uint8_t>(CudaSphData::VT_ENABLE_ATF_VISC, static_cast<uint8_t>(enable_atf_visc), 0);
  }
  void add_visc(float visc) {
    fbb_.AddElement<float>(CudaSphData::VT_VISC, visc, 0.0f);
  }
  void add_nu(float nu) {
    fbb_.AddElement<float>(CudaSphData::VT_NU, nu, 0.0f);
  }
  void add_bnu(float bnu) {
    fbb_.AddElement<float>(CudaSphData::VT_BNU, bnu, 0.0f);
  }
  void add_enable_sta_akinci13(bool enable_sta_akinci13) {
    fbb_.AddElement<uint8_t>(CudaSphData::VT_ENABLE_STA_AKINCI13, static_cast<uint8_t>(enable_sta_akinci13), 0);
  }
  void add_st_gamma(float st_gamma) {
    fbb_.AddElement<float>(CudaSphData::VT_ST_GAMMA, st_gamma, 1.0f);
  }
  void add_a_beta(float a_beta) {
    fbb_.AddElement<float>(CudaSphData::VT_A_BETA, a_beta, 1.0f);
  }
  void add_fixed_dt(float fixed_dt) {
    fbb_.AddElement<float>(CudaSphData::VT_FIXED_DT, fixed_dt, 0.0f);
  }
  explicit CudaSphDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaSphData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaSphData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaSphData> CreateCudaSphData(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rest_density = 0.0f,
    float rest_mass = 0.0f,
    float kernel_radius = 0.0f,
    float particle_radius = 0.0f,
    float stiff = 0.0f,
    const KIRI::FlatBuffers::float3 *gravity = 0,
    bool enable_atf_visc = false,
    float visc = 0.0f,
    float nu = 0.0f,
    float bnu = 0.0f,
    bool enable_sta_akinci13 = false,
    float st_gamma = 1.0f,
    float a_beta = 1.0f,
    float fixed_dt = 0.0f) {
  CudaSphDataBuilder builder_(_fbb);
  builder_.add_fixed_dt(fixed_dt);
  builder_.add_a_beta(a_beta);
  builder_.add_st_gamma(st_gamma);
  builder_.add_bnu(bnu);
  builder_.add_nu(nu);
  builder_.add_visc(visc);
  builder_.add_gravity(gravity);
  builder_.add_stiff(stiff);
  builder_.add_particle_radius(particle_radius);
  builder_.add_kernel_radius(kernel_radius);
  builder_.add_rest_mass(rest_mass);
  builder_.add_rest_density(rest_density);
  builder_.add_enable_sta_akinci13(enable_sta_akinci13);
  builder_.add_enable_atf_visc(enable_atf_visc);
  return builder_.Finish();
}

struct CudaSphEmitter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CudaSphEmitterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_EMIT_POS = 6,
    VT_EMIT_VEL = 8,
    VT_EMIT_TYPE = 10,
    VT_EMIT_RADIUS = 12,
    VT_EMIT_WIDTH = 14,
    VT_EMIT_HEIGHT = 16
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  const KIRI::FlatBuffers::float3 *emit_pos() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_EMIT_POS);
  }
  const KIRI::FlatBuffers::float3 *emit_vel() const {
    return GetStruct<const KIRI::FlatBuffers::float3 *>(VT_EMIT_VEL);
  }
  KIRI::FlatBuffers::CudaSphEmitterType emit_type() const {
    return static_cast<KIRI::FlatBuffers::CudaSphEmitterType>(GetField<int8_t>(VT_EMIT_TYPE, 0));
  }
  float emit_radius() const {
    return GetField<float>(VT_EMIT_RADIUS, 0.0f);
  }
  float emit_width() const {
    return GetField<float>(VT_EMIT_WIDTH, 0.0f);
  }
  float emit_height() const {
    return GetField<float>(VT_EMIT_HEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_EMIT_POS) &&
           VerifyField<KIRI::FlatBuffers::float3>(verifier, VT_EMIT_VEL) &&
           VerifyField<int8_t>(verifier, VT_EMIT_TYPE) &&
           VerifyField<float>(verifier, VT_EMIT_RADIUS) &&
           VerifyField<float>(verifier, VT_EMIT_WIDTH) &&
           VerifyField<float>(verifier, VT_EMIT_HEIGHT) &&
           verifier.EndTable();
  }
};

struct CudaSphEmitterBuilder {
  typedef CudaSphEmitter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(CudaSphEmitter::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_emit_pos(const KIRI::FlatBuffers::float3 *emit_pos) {
    fbb_.AddStruct(CudaSphEmitter::VT_EMIT_POS, emit_pos);
  }
  void add_emit_vel(const KIRI::FlatBuffers::float3 *emit_vel) {
    fbb_.AddStruct(CudaSphEmitter::VT_EMIT_VEL, emit_vel);
  }
  void add_emit_type(KIRI::FlatBuffers::CudaSphEmitterType emit_type) {
    fbb_.AddElement<int8_t>(CudaSphEmitter::VT_EMIT_TYPE, static_cast<int8_t>(emit_type), 0);
  }
  void add_emit_radius(float emit_radius) {
    fbb_.AddElement<float>(CudaSphEmitter::VT_EMIT_RADIUS, emit_radius, 0.0f);
  }
  void add_emit_width(float emit_width) {
    fbb_.AddElement<float>(CudaSphEmitter::VT_EMIT_WIDTH, emit_width, 0.0f);
  }
  void add_emit_height(float emit_height) {
    fbb_.AddElement<float>(CudaSphEmitter::VT_EMIT_HEIGHT, emit_height, 0.0f);
  }
  explicit CudaSphEmitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CudaSphEmitter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CudaSphEmitter>(end);
    return o;
  }
};

inline flatbuffers::Offset<CudaSphEmitter> CreateCudaSphEmitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    const KIRI::FlatBuffers::float3 *emit_pos = 0,
    const KIRI::FlatBuffers::float3 *emit_vel = 0,
    KIRI::FlatBuffers::CudaSphEmitterType emit_type = KIRI::FlatBuffers::CudaSphEmitterType_SQUARE,
    float emit_radius = 0.0f,
    float emit_width = 0.0f,
    float emit_height = 0.0f) {
  CudaSphEmitterBuilder builder_(_fbb);
  builder_.add_emit_height(emit_height);
  builder_.add_emit_width(emit_width);
  builder_.add_emit_radius(emit_radius);
  builder_.add_emit_vel(emit_vel);
  builder_.add_emit_pos(emit_pos);
  builder_.add_emit_type(emit_type);
  builder_.add_enable(enable);
  return builder_.Finish();
}

}  // namespace FlatBuffers
}  // namespace KIRI

#endif  // FLATBUFFERS_GENERATED_CUDASPHDATA_KIRI_FLATBUFFERS_H_
